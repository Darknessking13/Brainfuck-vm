const fs = require('fs');
const path = require('path');
const { performance } = require('perf_hooks'); // Import perf_hooks
const chalk = require('chalk'); // Import chalk (optional here, more useful in tests)

// Path to the JS glue code generated by Emscripten, relative to this index.js file
const wasmModuleGluePath = path.resolve(__dirname, 'bf_vm.js');

// Default VM options
const DEFAULT_MEMORY_SIZE = 90000;
const DEFAULT_MAX_OUTPUT_SIZE = 65536;

// --- Wasm Module State ---
let wasmModule = null;
let wasmRun = null;     // bfvm_run wrapper
let wasmAlloc = null;   // bfvm_mem_alloc wrapper
let wasmFree = null;    // bfvm_mem_free wrapper
let isInitialized = false;
let isInitializing = false; // Initialization lock

// --- Wasm Module Initialization ---
const initializeEngine = async () => {
    if (isInitialized || isInitializing) return;
    isInitializing = true;

    // Check if the glue code exists before trying to require it
    if (!fs.existsSync(wasmModuleGluePath)) {
        isInitializing = false;
        throw new Error(`Wasm glue code not found at ${wasmModuleGluePath}. Did you run 'npm run build'?`);
    }
    // Dynamically require the factory function
    const createBfvmModule = require(wasmModuleGluePath);

    try {
        wasmModule = await createBfvmModule();

        // Wrap the C functions (ensure these names match your C exports)
        wasmRun = wasmModule.cwrap(
            'bfvm_run', 'number',
            ['number', 'number', 'number', 'number', 'number', 'number', 'number']
        );
        wasmAlloc = wasmModule.cwrap('bfvm_mem_alloc', 'number', ['number']);
        wasmFree = wasmModule.cwrap('bfvm_mem_free', null, ['number']);

        isInitialized = true;
        isInitializing = false;
        // console.log(chalk.green('Brainfuck Wasm engine initialized successfully.'));

    } catch (err) {
        console.error(chalk.red("Error initializing Brainfuck Wasm engine:"), err);
        isInitialized = false;
        isInitializing = false;
        throw err;
    }
};

// --- Error Mapping ---
const getErrorMessage = (errorCode) => {
    switch (errorCode) {
        case 0: return "Success (unexpected error code 0)";
        case -1: return "Memory Out Of Bounds: Data pointer moved beyond tape limits.";
        case -2: return "Input End Of File Reached (during read operation).";
        case -3: return "Output Overflow: Output buffer is full.";
        case -4: return "Syntax Error: Unmatched closing bracket ']'.";
        case -5: return "Syntax Error: Unmatched opening bracket '['.";
        case -6: return "Memory Allocation Failed: Could not allocate Brainfuck memory tape.";
        case -10: return "Internal Error: Invalid arguments passed to bfvm_run.";
        default: return `Unknown error code: ${errorCode}`;
    }
};

// --- Main Execution Function ---
/**
 * Executes Brainfuck code using the Wasm VM.
 * @param {string} code The Brainfuck code to execute.
 * @param {string} [input=''] Optional input string for the ',' command.
 * @param {object} [options={}] Optional configuration.
 * @param {number} [options.memorySize=DEFAULT_MEMORY_SIZE] Size of the Brainfuck memory tape in bytes.
 * @param {number} [options.maxOutputSize=DEFAULT_MAX_OUTPUT_SIZE] Maximum size of the output buffer in bytes.
 * @returns {Promise<{ output: string, duration: number, memoryStats: { wasmHeapBefore: number, wasmHeapAfter: number } }>} A promise resolving with results.
 * @throws {Error} If initialization fails or execution encounters an error.
 */
async function execute(code, input = '', options = {}) {
    if (!isInitialized) {
        while (isInitializing) {
            await new Promise(resolve => setTimeout(resolve, 5));
        }
        if (!isInitialized) {
            await initializeEngine();
        }
    }

    if (!wasmModule || !wasmRun || !wasmAlloc || !wasmFree) {
        throw new Error("Brainfuck Wasm engine is not initialized properly.");
    }

    const memorySize = options.memorySize ?? DEFAULT_MEMORY_SIZE;
    const maxOutputSize = options.maxOutputSize ?? DEFAULT_MAX_OUTPUT_SIZE;

    if (memorySize <= 0) throw new Error("Invalid option: memorySize must be positive.");
    if (maxOutputSize <= 0) throw new Error("Invalid option: maxOutputSize must be positive.");

    let codePtr = 0, inputPtr = 0, outputPtr = 0;
    let resultCode = -10;
    let memoryBefore = 0, memoryAfter = 0;

    const perfMarkStart = `bf-exec-start-${Date.now()}-${Math.random()}`;
    const perfMarkEnd = `bf-exec-end-${Date.now()}-${Math.random()}`;
    const perfMeasureName = `BF Execute: ${code.substring(0, 20)}...`;

    try {
        performance.mark(perfMarkStart);
        memoryBefore = wasmModule.HEAPU8.buffer.byteLength;

        // 1. Encode & Allocate Wasm heap buffers
        const codeBytes = Buffer.from(code, 'utf8');
        const inputBytes = Buffer.from(input, 'utf8');
        codePtr = wasmAlloc(codeBytes.length);
        inputPtr = wasmAlloc(inputBytes.length > 0 ? inputBytes.length : 1);
        outputPtr = wasmAlloc(maxOutputSize);

        if (!codePtr || !inputPtr || !outputPtr) {
            throw new Error("Failed to allocate Wasm heap memory for buffers.");
        }

        // 2. Copy data to Wasm heap
        wasmModule.HEAPU8.set(codeBytes, codePtr);
        if (inputBytes.length > 0) wasmModule.HEAPU8.set(inputBytes, inputPtr);

        // 3. Execute Wasm function
        resultCode = wasmRun(
            codePtr, codeBytes.length,
            inputPtr, inputBytes.length,
            outputPtr, maxOutputSize, memorySize
        );

        memoryAfter = wasmModule.HEAPU8.buffer.byteLength;
        performance.mark(perfMarkEnd);

        // 4. Handle results/errors from Wasm
        if (resultCode < 0) {
            throw new Error(`Brainfuck VM Error: ${getErrorMessage(resultCode)} (Code: ${resultCode})`);
        }

        // 5. Read output from Wasm heap & Measure performance
        const outputBytes = wasmModule.HEAPU8.slice(outputPtr, outputPtr + resultCode);
        const outputString = Buffer.from(outputBytes).toString('utf8');

        performance.measure(perfMeasureName, perfMarkStart, perfMarkEnd);
        const measures = performance.getEntriesByName(perfMeasureName, 'measure');
        const duration = measures.length > 0 ? measures[0].duration : -1;

        // Cleanup performance marks/measures
        performance.clearMarks(perfMarkStart);
        performance.clearMarks(perfMarkEnd);
        performance.clearMeasures(perfMeasureName);

        return {
            output: outputString,
            duration: duration,
            memoryStats: { wasmHeapBefore: memoryBefore, wasmHeapAfter: memoryAfter }
        };

    } catch (error) {
        performance.clearMarks(perfMarkStart);
        performance.clearMarks(perfMarkEnd);
        performance.clearMeasures(perfMeasureName);
        throw error;
    } finally {
        // 6. IMPORTANT: Free Wasm *heap* buffers
        if (wasmFree) {
            if (codePtr) wasmFree(codePtr);
            if (inputPtr) wasmFree(inputPtr);
            if (outputPtr) wasmFree(outputPtr);
        }
    }
}

// Export the public API
module.exports = {
    execute,
    initializeEngine, // Expose if direct initialization is needed
    DEFAULT_MEMORY_SIZE,
    DEFAULT_MAX_OUTPUT_SIZE
};